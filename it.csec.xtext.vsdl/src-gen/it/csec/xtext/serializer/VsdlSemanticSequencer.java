/*
 * generated by Xtext 2.35.0
 */
package it.csec.xtext.serializer;

import com.google.inject.Inject;
import it.csec.xtext.services.VsdlGrammarAccess;
import it.csec.xtext.vsdl.AndOr;
import it.csec.xtext.vsdl.At;
import it.csec.xtext.vsdl.CPU;
import it.csec.xtext.vsdl.CPUFrequency;
import it.csec.xtext.vsdl.ConfigOptions;
import it.csec.xtext.vsdl.ConfigPair;
import it.csec.xtext.vsdl.Disk;
import it.csec.xtext.vsdl.DiskSize;
import it.csec.xtext.vsdl.Flavour;
import it.csec.xtext.vsdl.Gateway;
import it.csec.xtext.vsdl.IP;
import it.csec.xtext.vsdl.IPAddress;
import it.csec.xtext.vsdl.IPRange;
import it.csec.xtext.vsdl.IPRangeA;
import it.csec.xtext.vsdl.Model;
import it.csec.xtext.vsdl.Multiplication;
import it.csec.xtext.vsdl.Network;
import it.csec.xtext.vsdl.NetworkConstraint;
import it.csec.xtext.vsdl.Node;
import it.csec.xtext.vsdl.NodeConstraint;
import it.csec.xtext.vsdl.Not;
import it.csec.xtext.vsdl.OS;
import it.csec.xtext.vsdl.OSFamily;
import it.csec.xtext.vsdl.PlusMinus;
import it.csec.xtext.vsdl.Ram;
import it.csec.xtext.vsdl.RamSize;
import it.csec.xtext.vsdl.SoftwareDependency;
import it.csec.xtext.vsdl.SoftwareInstallation;
import it.csec.xtext.vsdl.Switch;
import it.csec.xtext.vsdl.TimeExpr;
import it.csec.xtext.vsdl.TimeInterval;
import it.csec.xtext.vsdl.VsdlPackage;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class VsdlSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private VsdlGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == VsdlPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case VsdlPackage.AND_OR:
				if (rule == grammarAccess.getNetworkConstraintRule()
						|| rule == grammarAccess.getSimpleNetworkConstraintRule()
						|| rule == grammarAccess.getSimpleNetworkConstraintAndOrRule()
						|| action == grammarAccess.getSimpleNetworkConstraintAndOrAccess().getAndOrLeftAction_1_0_0()
						|| rule == grammarAccess.getSimpleNetworkConstraintNotRule()
						|| rule == grammarAccess.getSimpleNetworkConstraintARule()) {
					sequence_SimpleNetworkConstraintAndOr(context, (AndOr) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getNodeConstraintRule()
						|| rule == grammarAccess.getSimpleNodeConstraintRule()
						|| rule == grammarAccess.getSimpleNodeConstraintAndOrRule()
						|| action == grammarAccess.getSimpleNodeConstraintAndOrAccess().getAndOrLeftAction_1_0_0()
						|| rule == grammarAccess.getSimpleNodeConstraintNotRule()
						|| rule == grammarAccess.getSimpleNodeConstraintARule()) {
					sequence_SimpleNodeConstraintAndOr(context, (AndOr) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getUpdateTriggerConstraintRule()
						|| rule == grammarAccess.getUpdateTriggerConstraintAndOrRule()
						|| action == grammarAccess.getUpdateTriggerConstraintAndOrAccess().getAndOrLeftAction_1_0_0()
						|| rule == grammarAccess.getUpdateTriggerConstraintNotRule()
						|| rule == grammarAccess.getUpdateTriggerConstraintARule()) {
					sequence_UpdateTriggerConstraintAndOr(context, (AndOr) semanticObject); 
					return; 
				}
				else break;
			case VsdlPackage.AT:
				sequence_UpdateTriggerConstraintA(context, (At) semanticObject); 
				return; 
			case VsdlPackage.CPU:
				sequence_NodeHardwareConstraintA(context, (CPU) semanticObject); 
				return; 
			case VsdlPackage.CPU_FREQUENCY:
				sequence_CPUFrequency(context, (CPUFrequency) semanticObject); 
				return; 
			case VsdlPackage.CONFIG_OPTIONS:
				sequence_ConfigOptions(context, (ConfigOptions) semanticObject); 
				return; 
			case VsdlPackage.CONFIG_PAIR:
				sequence_ConfigPair(context, (ConfigPair) semanticObject); 
				return; 
			case VsdlPackage.DISK:
				sequence_NodeHardwareConstraintA(context, (Disk) semanticObject); 
				return; 
			case VsdlPackage.DISK_SIZE:
				sequence_DiskSize(context, (DiskSize) semanticObject); 
				return; 
			case VsdlPackage.FLAVOUR:
				sequence_NodeHardwareConstraintA(context, (Flavour) semanticObject); 
				return; 
			case VsdlPackage.GATEWAY:
				sequence_NetworkGatewayConstraint(context, (Gateway) semanticObject); 
				return; 
			case VsdlPackage.IP:
				sequence_NetworkParticipantsConstraint(context, (IP) semanticObject); 
				return; 
			case VsdlPackage.IP_ADDRESS:
				sequence_IPAddress(context, (IPAddress) semanticObject); 
				return; 
			case VsdlPackage.IP_RANGE:
				sequence_NetworkGatewayConstraint(context, (IPRange) semanticObject); 
				return; 
			case VsdlPackage.IP_RANGE_A:
				sequence_IPRangeA(context, (IPRangeA) semanticObject); 
				return; 
			case VsdlPackage.MODEL:
				sequence_Model(context, (Model) semanticObject); 
				return; 
			case VsdlPackage.MULTIPLICATION:
				sequence_TimeExprMultiplication(context, (Multiplication) semanticObject); 
				return; 
			case VsdlPackage.NETWORK:
				sequence_Network(context, (Network) semanticObject); 
				return; 
			case VsdlPackage.NETWORK_CONSTRAINT:
				sequence_GuardedNetworkConstraint(context, (NetworkConstraint) semanticObject); 
				return; 
			case VsdlPackage.NODE:
				sequence_Node(context, (Node) semanticObject); 
				return; 
			case VsdlPackage.NODE_CONSTRAINT:
				if (rule == grammarAccess.getGuardedNodeConstraintRule()) {
					sequence_GuardedNodeConstraint(context, (NodeConstraint) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getNodeConstraintRule()) {
					sequence_GuardedNodeConstraint_NodeSoftwareConstraintA(context, (NodeConstraint) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getSimpleNodeConstraintRule()
						|| rule == grammarAccess.getSimpleNodeConstraintAndOrRule()
						|| action == grammarAccess.getSimpleNodeConstraintAndOrAccess().getAndOrLeftAction_1_0_0()
						|| rule == grammarAccess.getSimpleNodeConstraintNotRule()
						|| rule == grammarAccess.getSimpleNodeConstraintARule()
						|| rule == grammarAccess.getNodeSoftwareConstraintARule()) {
					sequence_NodeSoftwareConstraintA(context, (NodeConstraint) semanticObject); 
					return; 
				}
				else break;
			case VsdlPackage.NOT:
				if (rule == grammarAccess.getNetworkConstraintRule()
						|| rule == grammarAccess.getSimpleNetworkConstraintRule()
						|| rule == grammarAccess.getSimpleNetworkConstraintAndOrRule()
						|| action == grammarAccess.getSimpleNetworkConstraintAndOrAccess().getAndOrLeftAction_1_0_0()
						|| rule == grammarAccess.getSimpleNetworkConstraintNotRule()
						|| rule == grammarAccess.getSimpleNetworkConstraintARule()) {
					sequence_SimpleNetworkConstraintNot(context, (Not) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getNodeConstraintRule()
						|| rule == grammarAccess.getSimpleNodeConstraintRule()
						|| rule == grammarAccess.getSimpleNodeConstraintAndOrRule()
						|| action == grammarAccess.getSimpleNodeConstraintAndOrAccess().getAndOrLeftAction_1_0_0()
						|| rule == grammarAccess.getSimpleNodeConstraintNotRule()
						|| rule == grammarAccess.getSimpleNodeConstraintARule()) {
					sequence_SimpleNodeConstraintNot(context, (Not) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getUpdateTriggerConstraintRule()
						|| rule == grammarAccess.getUpdateTriggerConstraintAndOrRule()
						|| action == grammarAccess.getUpdateTriggerConstraintAndOrAccess().getAndOrLeftAction_1_0_0()
						|| rule == grammarAccess.getUpdateTriggerConstraintNotRule()
						|| rule == grammarAccess.getUpdateTriggerConstraintARule()) {
					sequence_UpdateTriggerConstraintNot(context, (Not) semanticObject); 
					return; 
				}
				else break;
			case VsdlPackage.OS:
				sequence_NodeSoftwareConstraintA(context, (OS) semanticObject); 
				return; 
			case VsdlPackage.OS_FAMILY:
				sequence_NodeSoftwareConstraintA(context, (OSFamily) semanticObject); 
				return; 
			case VsdlPackage.PLUS_MINUS:
				sequence_TimeExprAddition(context, (PlusMinus) semanticObject); 
				return; 
			case VsdlPackage.RAM:
				sequence_NodeHardwareConstraintA(context, (Ram) semanticObject); 
				return; 
			case VsdlPackage.RAM_SIZE:
				sequence_RamSize(context, (RamSize) semanticObject); 
				return; 
			case VsdlPackage.SOFTWARE_DEPENDENCY:
				sequence_SoftwareDependency(context, (SoftwareDependency) semanticObject); 
				return; 
			case VsdlPackage.SOFTWARE_INSTALLATION:
				sequence_SoftwareInstallation(context, (SoftwareInstallation) semanticObject); 
				return; 
			case VsdlPackage.SWITCH:
				sequence_UpdateTriggerConstraintA(context, (Switch) semanticObject); 
				return; 
			case VsdlPackage.TIME_EXPR:
				sequence_TimeExprA(context, (TimeExpr) semanticObject); 
				return; 
			case VsdlPackage.TIME_INTERVAL:
				sequence_TimeInterval(context, (TimeInterval) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * <pre>
	 * Contexts:
	 *     CPUFrequency returns CPUFrequency
	 *
	 * Constraint:
	 *     (value=INT (unit='MHz' | unit='GHz' | unit='THz'))
	 * </pre>
	 */
	protected void sequence_CPUFrequency(ISerializationContext context, CPUFrequency semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ConfigOptions returns ConfigOptions
	 *
	 * Constraint:
	 *     (configPairs+=ConfigPair configPairs+=ConfigPair*)
	 * </pre>
	 */
	protected void sequence_ConfigOptions(ISerializationContext context, ConfigOptions semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ConfigPair returns ConfigPair
	 *
	 * Constraint:
	 *     (key=ID value=STRING)
	 * </pre>
	 */
	protected void sequence_ConfigPair(ISerializationContext context, ConfigPair semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, VsdlPackage.Literals.CONFIG_PAIR__KEY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, VsdlPackage.Literals.CONFIG_PAIR__KEY));
			if (transientValues.isValueTransient(semanticObject, VsdlPackage.Literals.CONFIG_PAIR__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, VsdlPackage.Literals.CONFIG_PAIR__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getConfigPairAccess().getKeyIDTerminalRuleCall_0_0(), semanticObject.getKey());
		feeder.accept(grammarAccess.getConfigPairAccess().getValueSTRINGTerminalRuleCall_2_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     DiskSize returns DiskSize
	 *
	 * Constraint:
	 *     (value=INT (unit='MB' | unit='GB' | unit='TB'))
	 * </pre>
	 */
	protected void sequence_DiskSize(ISerializationContext context, DiskSize semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     NetworkConstraint returns NetworkConstraint
	 *     GuardedNetworkConstraint returns NetworkConstraint
	 *
	 * Constraint:
	 *     (networktriggerconstraint=UpdateTriggerConstraint networkconstraint=SimpleNetworkConstraint)
	 * </pre>
	 */
	protected void sequence_GuardedNetworkConstraint(ISerializationContext context, NetworkConstraint semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, VsdlPackage.Literals.NETWORK_CONSTRAINT__NETWORKTRIGGERCONSTRAINT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, VsdlPackage.Literals.NETWORK_CONSTRAINT__NETWORKTRIGGERCONSTRAINT));
			if (transientValues.isValueTransient(semanticObject, VsdlPackage.Literals.NETWORK_CONSTRAINT__NETWORKCONSTRAINT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, VsdlPackage.Literals.NETWORK_CONSTRAINT__NETWORKCONSTRAINT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getGuardedNetworkConstraintAccess().getNetworktriggerconstraintUpdateTriggerConstraintParserRuleCall_1_0(), semanticObject.getNetworktriggerconstraint());
		feeder.accept(grammarAccess.getGuardedNetworkConstraintAccess().getNetworkconstraintSimpleNetworkConstraintParserRuleCall_4_0(), semanticObject.getNetworkconstraint());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     GuardedNodeConstraint returns NodeConstraint
	 *
	 * Constraint:
	 *     (triggerconstraint=UpdateTriggerConstraint nodeconstraint=SimpleNodeConstraint)
	 * </pre>
	 */
	protected void sequence_GuardedNodeConstraint(ISerializationContext context, NodeConstraint semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, VsdlPackage.Literals.NODE_CONSTRAINT__TRIGGERCONSTRAINT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, VsdlPackage.Literals.NODE_CONSTRAINT__TRIGGERCONSTRAINT));
			if (transientValues.isValueTransient(semanticObject, VsdlPackage.Literals.NODE_CONSTRAINT__NODECONSTRAINT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, VsdlPackage.Literals.NODE_CONSTRAINT__NODECONSTRAINT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getGuardedNodeConstraintAccess().getTriggerconstraintUpdateTriggerConstraintParserRuleCall_1_0(), semanticObject.getTriggerconstraint());
		feeder.accept(grammarAccess.getGuardedNodeConstraintAccess().getNodeconstraintSimpleNodeConstraintParserRuleCall_4_0(), semanticObject.getNodeconstraint());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     NodeConstraint returns NodeConstraint
	 *
	 * Constraint:
	 *     ((triggerconstraint=UpdateTriggerConstraint nodeconstraint=SimpleNodeConstraint) | software=SoftwareInstallation)
	 * </pre>
	 */
	protected void sequence_GuardedNodeConstraint_NodeSoftwareConstraintA(ISerializationContext context, NodeConstraint semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     IPAddress returns IPAddress
	 *
	 * Constraint:
	 *     (octet1=INT octet2=INT octet3=INT octet4=INT)
	 * </pre>
	 */
	protected void sequence_IPAddress(ISerializationContext context, IPAddress semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, VsdlPackage.Literals.IP_ADDRESS__OCTET1) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, VsdlPackage.Literals.IP_ADDRESS__OCTET1));
			if (transientValues.isValueTransient(semanticObject, VsdlPackage.Literals.IP_ADDRESS__OCTET2) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, VsdlPackage.Literals.IP_ADDRESS__OCTET2));
			if (transientValues.isValueTransient(semanticObject, VsdlPackage.Literals.IP_ADDRESS__OCTET3) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, VsdlPackage.Literals.IP_ADDRESS__OCTET3));
			if (transientValues.isValueTransient(semanticObject, VsdlPackage.Literals.IP_ADDRESS__OCTET4) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, VsdlPackage.Literals.IP_ADDRESS__OCTET4));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getIPAddressAccess().getOctet1INTTerminalRuleCall_0_0(), semanticObject.getOctet1());
		feeder.accept(grammarAccess.getIPAddressAccess().getOctet2INTTerminalRuleCall_2_0(), semanticObject.getOctet2());
		feeder.accept(grammarAccess.getIPAddressAccess().getOctet3INTTerminalRuleCall_4_0(), semanticObject.getOctet3());
		feeder.accept(grammarAccess.getIPAddressAccess().getOctet4INTTerminalRuleCall_6_0(), semanticObject.getOctet4());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     IPRangeA returns IPRangeA
	 *
	 * Constraint:
	 *     (address=IPAddress bitmask=INT)
	 * </pre>
	 */
	protected void sequence_IPRangeA(ISerializationContext context, IPRangeA semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, VsdlPackage.Literals.IP_RANGE_A__ADDRESS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, VsdlPackage.Literals.IP_RANGE_A__ADDRESS));
			if (transientValues.isValueTransient(semanticObject, VsdlPackage.Literals.IP_RANGE_A__BITMASK) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, VsdlPackage.Literals.IP_RANGE_A__BITMASK));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getIPRangeAAccess().getAddressIPAddressParserRuleCall_0_0(), semanticObject.getAddress());
		feeder.accept(grammarAccess.getIPRangeAAccess().getBitmaskINTTerminalRuleCall_2_0(), semanticObject.getBitmask());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Model returns Model
	 *
	 * Constraint:
	 *     (name=ID TimeToUse=TimeInterval? Elements+=ScenElem*)
	 * </pre>
	 */
	protected void sequence_Model(ISerializationContext context, Model semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     NetworkConstraint returns Gateway
	 *     SimpleNetworkConstraint returns Gateway
	 *     SimpleNetworkConstraintAndOr returns Gateway
	 *     SimpleNetworkConstraintAndOr.AndOr_1_0_0 returns Gateway
	 *     SimpleNetworkConstraintNot returns Gateway
	 *     SimpleNetworkConstraintA returns Gateway
	 *     NetworkGatewayConstraint returns Gateway
	 *
	 * Constraint:
	 *     internet?='Internet'
	 * </pre>
	 */
	protected void sequence_NetworkGatewayConstraint(ISerializationContext context, Gateway semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, VsdlPackage.Literals.GATEWAY__INTERNET) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, VsdlPackage.Literals.GATEWAY__INTERNET));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNetworkGatewayConstraintAccess().getInternetInternetKeyword_1_7_0(), semanticObject.isInternet());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     NetworkConstraint returns IPRange
	 *     SimpleNetworkConstraint returns IPRange
	 *     SimpleNetworkConstraintAndOr returns IPRange
	 *     SimpleNetworkConstraintAndOr.AndOr_1_0_0 returns IPRange
	 *     SimpleNetworkConstraintNot returns IPRange
	 *     SimpleNetworkConstraintA returns IPRange
	 *     NetworkGatewayConstraint returns IPRange
	 *
	 * Constraint:
	 *     range=IPRangeA
	 * </pre>
	 */
	protected void sequence_NetworkGatewayConstraint(ISerializationContext context, IPRange semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, VsdlPackage.Literals.IP_RANGE__RANGE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, VsdlPackage.Literals.IP_RANGE__RANGE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNetworkGatewayConstraintAccess().getRangeIPRangeAParserRuleCall_0_4_0(), semanticObject.getRange());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     NetworkConstraint returns IP
	 *     SimpleNetworkConstraint returns IP
	 *     SimpleNetworkConstraintAndOr returns IP
	 *     SimpleNetworkConstraintAndOr.AndOr_1_0_0 returns IP
	 *     SimpleNetworkConstraintNot returns IP
	 *     SimpleNetworkConstraintA returns IP
	 *     NetworkParticipantsConstraint returns IP
	 *
	 * Constraint:
	 *     ((id=[ScenElem|ID] op='connected') | (id=[ScenElem|ID] op='IP' address=IPAddress))
	 * </pre>
	 */
	protected void sequence_NetworkParticipantsConstraint(ISerializationContext context, IP semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ScenElem returns Network
	 *     Network returns Network
	 *
	 * Constraint:
	 *     (name=ID constraints+=NetworkConstraint*)
	 * </pre>
	 */
	protected void sequence_Network(ISerializationContext context, Network semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     NodeConstraint returns CPU
	 *     SimpleNodeConstraint returns CPU
	 *     SimpleNodeConstraintAndOr returns CPU
	 *     SimpleNodeConstraintAndOr.AndOr_1_0_0 returns CPU
	 *     SimpleNodeConstraintNot returns CPU
	 *     SimpleNodeConstraintA returns CPU
	 *     NodeHardwareConstraintA returns CPU
	 *
	 * Constraint:
	 *     ((op='equal' value=CPUFrequency) | (op='faster' value=CPUFrequency) | (op='slower' value=CPUFrequency) | (sameas?='of' id=[Node|ID]))
	 * </pre>
	 */
	protected void sequence_NodeHardwareConstraintA(ISerializationContext context, CPU semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     NodeConstraint returns Disk
	 *     SimpleNodeConstraint returns Disk
	 *     SimpleNodeConstraintAndOr returns Disk
	 *     SimpleNodeConstraintAndOr.AndOr_1_0_0 returns Disk
	 *     SimpleNodeConstraintNot returns Disk
	 *     SimpleNodeConstraintA returns Disk
	 *     NodeHardwareConstraintA returns Disk
	 *
	 * Constraint:
	 *     ((op='equal' value=DiskSize) | (op='larger' value=DiskSize) | (op='smaller' value=DiskSize) | (sameas?='of' id=[Node|ID]))
	 * </pre>
	 */
	protected void sequence_NodeHardwareConstraintA(ISerializationContext context, Disk semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     NodeConstraint returns Flavour
	 *     SimpleNodeConstraint returns Flavour
	 *     SimpleNodeConstraintAndOr returns Flavour
	 *     SimpleNodeConstraintAndOr.AndOr_1_0_0 returns Flavour
	 *     SimpleNodeConstraintNot returns Flavour
	 *     SimpleNodeConstraintA returns Flavour
	 *     NodeHardwareConstraintA returns Flavour
	 *
	 * Constraint:
	 *     profile=HardwareProfile
	 * </pre>
	 */
	protected void sequence_NodeHardwareConstraintA(ISerializationContext context, Flavour semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, VsdlPackage.Literals.FLAVOUR__PROFILE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, VsdlPackage.Literals.FLAVOUR__PROFILE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNodeHardwareConstraintAAccess().getProfileHardwareProfileEnumRuleCall_12_2_0(), semanticObject.getProfile());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     NodeConstraint returns Ram
	 *     SimpleNodeConstraint returns Ram
	 *     SimpleNodeConstraintAndOr returns Ram
	 *     SimpleNodeConstraintAndOr.AndOr_1_0_0 returns Ram
	 *     SimpleNodeConstraintNot returns Ram
	 *     SimpleNodeConstraintA returns Ram
	 *     NodeHardwareConstraintA returns Ram
	 *
	 * Constraint:
	 *     ((op='equal' value=RamSize) | (op='larger' value=RamSize) | (op='smaller' value=RamSize) | (sameas?='of' id=[Node|ID]))
	 * </pre>
	 */
	protected void sequence_NodeHardwareConstraintA(ISerializationContext context, Ram semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     SimpleNodeConstraint returns NodeConstraint
	 *     SimpleNodeConstraintAndOr returns NodeConstraint
	 *     SimpleNodeConstraintAndOr.AndOr_1_0_0 returns NodeConstraint
	 *     SimpleNodeConstraintNot returns NodeConstraint
	 *     SimpleNodeConstraintA returns NodeConstraint
	 *     NodeSoftwareConstraintA returns NodeConstraint
	 *
	 * Constraint:
	 *     software=SoftwareInstallation
	 * </pre>
	 */
	protected void sequence_NodeSoftwareConstraintA(ISerializationContext context, NodeConstraint semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, VsdlPackage.Literals.NODE_CONSTRAINT__SOFTWARE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, VsdlPackage.Literals.NODE_CONSTRAINT__SOFTWARE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNodeSoftwareConstraintAAccess().getSoftwareSoftwareInstallationParserRuleCall_2_2_0(), semanticObject.getSoftware());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     NodeConstraint returns OS
	 *     SimpleNodeConstraint returns OS
	 *     SimpleNodeConstraintAndOr returns OS
	 *     SimpleNodeConstraintAndOr.AndOr_1_0_0 returns OS
	 *     SimpleNodeConstraintNot returns OS
	 *     SimpleNodeConstraintA returns OS
	 *     NodeSoftwareConstraintA returns OS
	 *
	 * Constraint:
	 *     version=OSVersionE
	 * </pre>
	 */
	protected void sequence_NodeSoftwareConstraintA(ISerializationContext context, OS semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, VsdlPackage.Literals.OS__VERSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, VsdlPackage.Literals.OS__VERSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNodeSoftwareConstraintAAccess().getVersionOSVersionEParserRuleCall_0_4_0(), semanticObject.getVersion());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     NodeConstraint returns OSFamily
	 *     SimpleNodeConstraint returns OSFamily
	 *     SimpleNodeConstraintAndOr returns OSFamily
	 *     SimpleNodeConstraintAndOr.AndOr_1_0_0 returns OSFamily
	 *     SimpleNodeConstraintNot returns OSFamily
	 *     SimpleNodeConstraintA returns OSFamily
	 *     NodeSoftwareConstraintA returns OSFamily
	 *
	 * Constraint:
	 *     family=OSFamilyE
	 * </pre>
	 */
	protected void sequence_NodeSoftwareConstraintA(ISerializationContext context, OSFamily semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, VsdlPackage.Literals.OS_FAMILY__FAMILY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, VsdlPackage.Literals.OS_FAMILY__FAMILY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNodeSoftwareConstraintAAccess().getFamilyOSFamilyEParserRuleCall_1_5_0(), semanticObject.getFamily());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ScenElem returns Node
	 *     Node returns Node
	 *
	 * Constraint:
	 *     (name=ID constraints+=NodeConstraint*)
	 * </pre>
	 */
	protected void sequence_Node(ISerializationContext context, Node semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     RamSize returns RamSize
	 *
	 * Constraint:
	 *     (value=INT (unit='MB' | unit='GB' | unit='TB'))
	 * </pre>
	 */
	protected void sequence_RamSize(ISerializationContext context, RamSize semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     NetworkConstraint returns AndOr
	 *     SimpleNetworkConstraint returns AndOr
	 *     SimpleNetworkConstraintAndOr returns AndOr
	 *     SimpleNetworkConstraintAndOr.AndOr_1_0_0 returns AndOr
	 *     SimpleNetworkConstraintNot returns AndOr
	 *     SimpleNetworkConstraintA returns AndOr
	 *
	 * Constraint:
	 *     (left=SimpleNetworkConstraintAndOr_AndOr_1_0_0 (op='and' | op='or') right=SimpleNetworkConstraintNot)
	 * </pre>
	 */
	protected void sequence_SimpleNetworkConstraintAndOr(ISerializationContext context, AndOr semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     NetworkConstraint returns Not
	 *     SimpleNetworkConstraint returns Not
	 *     SimpleNetworkConstraintAndOr returns Not
	 *     SimpleNetworkConstraintAndOr.AndOr_1_0_0 returns Not
	 *     SimpleNetworkConstraintNot returns Not
	 *     SimpleNetworkConstraintA returns Not
	 *
	 * Constraint:
	 *     constraint=SimpleNetworkConstraintA
	 * </pre>
	 */
	protected void sequence_SimpleNetworkConstraintNot(ISerializationContext context, Not semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, VsdlPackage.Literals.NOT__CONSTRAINT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, VsdlPackage.Literals.NOT__CONSTRAINT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSimpleNetworkConstraintNotAccess().getConstraintSimpleNetworkConstraintAParserRuleCall_0_2_0(), semanticObject.getConstraint());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     NodeConstraint returns AndOr
	 *     SimpleNodeConstraint returns AndOr
	 *     SimpleNodeConstraintAndOr returns AndOr
	 *     SimpleNodeConstraintAndOr.AndOr_1_0_0 returns AndOr
	 *     SimpleNodeConstraintNot returns AndOr
	 *     SimpleNodeConstraintA returns AndOr
	 *
	 * Constraint:
	 *     (left=SimpleNodeConstraintAndOr_AndOr_1_0_0 (op='and' | op='or') right=SimpleNodeConstraintNot)
	 * </pre>
	 */
	protected void sequence_SimpleNodeConstraintAndOr(ISerializationContext context, AndOr semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     NodeConstraint returns Not
	 *     SimpleNodeConstraint returns Not
	 *     SimpleNodeConstraintAndOr returns Not
	 *     SimpleNodeConstraintAndOr.AndOr_1_0_0 returns Not
	 *     SimpleNodeConstraintNot returns Not
	 *     SimpleNodeConstraintA returns Not
	 *
	 * Constraint:
	 *     constraint=SimpleNodeConstraintA
	 * </pre>
	 */
	protected void sequence_SimpleNodeConstraintNot(ISerializationContext context, Not semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, VsdlPackage.Literals.NOT__CONSTRAINT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, VsdlPackage.Literals.NOT__CONSTRAINT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSimpleNodeConstraintNotAccess().getConstraintSimpleNodeConstraintAParserRuleCall_0_2_0(), semanticObject.getConstraint());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     SoftwareDependency returns SoftwareDependency
	 *
	 * Constraint:
	 *     dependencyID=ID
	 * </pre>
	 */
	protected void sequence_SoftwareDependency(ISerializationContext context, SoftwareDependency semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, VsdlPackage.Literals.SOFTWARE_DEPENDENCY__DEPENDENCY_ID) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, VsdlPackage.Literals.SOFTWARE_DEPENDENCY__DEPENDENCY_ID));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSoftwareDependencyAccess().getDependencyIDIDTerminalRuleCall_0(), semanticObject.getDependencyID());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     SoftwareInstallation returns SoftwareInstallation
	 *
	 * Constraint:
	 *     (softwareID=ID version=VersionNumber? (dependencies+=SoftwareDependency dependencies+=SoftwareDependency*)? config=ConfigOptions?)
	 * </pre>
	 */
	protected void sequence_SoftwareInstallation(ISerializationContext context, SoftwareInstallation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     TimeExpr returns TimeExpr
	 *     TimeExprAddition returns TimeExpr
	 *     TimeExprAddition.PlusMinus_1_0_0 returns TimeExpr
	 *     TimeExprMultiplication returns TimeExpr
	 *     TimeExprMultiplication.Multiplication_1_0_0 returns TimeExpr
	 *     TimeExprA returns TimeExpr
	 *
	 * Constraint:
	 *     (variable=ID | interval=TimeInterval)
	 * </pre>
	 */
	protected void sequence_TimeExprA(ISerializationContext context, TimeExpr semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     TimeExpr returns PlusMinus
	 *     TimeExprAddition returns PlusMinus
	 *     TimeExprAddition.PlusMinus_1_0_0 returns PlusMinus
	 *     TimeExprMultiplication returns PlusMinus
	 *     TimeExprMultiplication.Multiplication_1_0_0 returns PlusMinus
	 *     TimeExprA returns PlusMinus
	 *
	 * Constraint:
	 *     (left=TimeExprAddition_PlusMinus_1_0_0 (op='+' | op='-') right=TimeExprMultiplication)
	 * </pre>
	 */
	protected void sequence_TimeExprAddition(ISerializationContext context, PlusMinus semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     TimeExpr returns Multiplication
	 *     TimeExprAddition returns Multiplication
	 *     TimeExprAddition.PlusMinus_1_0_0 returns Multiplication
	 *     TimeExprMultiplication returns Multiplication
	 *     TimeExprMultiplication.Multiplication_1_0_0 returns Multiplication
	 *     TimeExprA returns Multiplication
	 *
	 * Constraint:
	 *     (left=TimeExprMultiplication_Multiplication_1_0_0 op='*' right=TimeExprA)
	 * </pre>
	 */
	protected void sequence_TimeExprMultiplication(ISerializationContext context, Multiplication semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, VsdlPackage.Literals.TIME_EXPR__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, VsdlPackage.Literals.TIME_EXPR__LEFT));
			if (transientValues.isValueTransient(semanticObject, VsdlPackage.Literals.TIME_EXPR__OP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, VsdlPackage.Literals.TIME_EXPR__OP));
			if (transientValues.isValueTransient(semanticObject, VsdlPackage.Literals.TIME_EXPR__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, VsdlPackage.Literals.TIME_EXPR__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTimeExprMultiplicationAccess().getMultiplicationLeftAction_1_0_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getTimeExprMultiplicationAccess().getOpAsteriskKeyword_1_0_1_0(), semanticObject.getOp());
		feeder.accept(grammarAccess.getTimeExprMultiplicationAccess().getRightTimeExprAParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     TimeInterval returns TimeInterval
	 *
	 * Constraint:
	 *     value=INT
	 * </pre>
	 */
	protected void sequence_TimeInterval(ISerializationContext context, TimeInterval semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, VsdlPackage.Literals.TIME_INTERVAL__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, VsdlPackage.Literals.TIME_INTERVAL__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTimeIntervalAccess().getValueINTTerminalRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     UpdateTriggerConstraint returns At
	 *     UpdateTriggerConstraintAndOr returns At
	 *     UpdateTriggerConstraintAndOr.AndOr_1_0_0 returns At
	 *     UpdateTriggerConstraintNot returns At
	 *     UpdateTriggerConstraintA returns At
	 *
	 * Constraint:
	 *     ((op='least' variable=ID texp=TimeExpr) | (op='most' variable=ID texp=TimeExpr))
	 * </pre>
	 */
	protected void sequence_UpdateTriggerConstraintA(ISerializationContext context, At semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     UpdateTriggerConstraint returns Switch
	 *     UpdateTriggerConstraintAndOr returns Switch
	 *     UpdateTriggerConstraintAndOr.AndOr_1_0_0 returns Switch
	 *     UpdateTriggerConstraintNot returns Switch
	 *     UpdateTriggerConstraintA returns Switch
	 *
	 * Constraint:
	 *     (variable=ID texp=TimeExpr)
	 * </pre>
	 */
	protected void sequence_UpdateTriggerConstraintA(ISerializationContext context, Switch semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, VsdlPackage.Literals.SWITCH__VARIABLE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, VsdlPackage.Literals.SWITCH__VARIABLE));
			if (transientValues.isValueTransient(semanticObject, VsdlPackage.Literals.SWITCH__TEXP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, VsdlPackage.Literals.SWITCH__TEXP));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getUpdateTriggerConstraintAAccess().getVariableIDTerminalRuleCall_3_3_0(), semanticObject.getVariable());
		feeder.accept(grammarAccess.getUpdateTriggerConstraintAAccess().getTexpTimeExprParserRuleCall_3_5_0(), semanticObject.getTexp());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     UpdateTriggerConstraint returns AndOr
	 *     UpdateTriggerConstraintAndOr returns AndOr
	 *     UpdateTriggerConstraintAndOr.AndOr_1_0_0 returns AndOr
	 *     UpdateTriggerConstraintNot returns AndOr
	 *     UpdateTriggerConstraintA returns AndOr
	 *
	 * Constraint:
	 *     (left=UpdateTriggerConstraintAndOr_AndOr_1_0_0 (op='and' | op='or') right=UpdateTriggerConstraintNot)
	 * </pre>
	 */
	protected void sequence_UpdateTriggerConstraintAndOr(ISerializationContext context, AndOr semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     UpdateTriggerConstraint returns Not
	 *     UpdateTriggerConstraintAndOr returns Not
	 *     UpdateTriggerConstraintAndOr.AndOr_1_0_0 returns Not
	 *     UpdateTriggerConstraintNot returns Not
	 *     UpdateTriggerConstraintA returns Not
	 *
	 * Constraint:
	 *     constraint=UpdateTriggerConstraintA
	 * </pre>
	 */
	protected void sequence_UpdateTriggerConstraintNot(ISerializationContext context, Not semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, VsdlPackage.Literals.NOT__CONSTRAINT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, VsdlPackage.Literals.NOT__CONSTRAINT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getUpdateTriggerConstraintNotAccess().getConstraintUpdateTriggerConstraintAParserRuleCall_0_2_0(), semanticObject.getConstraint());
		feeder.finish();
	}
	
	
}
